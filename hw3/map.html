<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>

  <style>
    .nhood-outline {
      fill: none;
      stroke: #006400;
      stroke-width: 2px;
    }

    .nhood {
      fill: #F0F0F0;
      stroke: #4682B4;
      stroke-width: 1px;
    }

    rect.handle,
    rect.overlay {
      display: none;
    }
  </style>
</head>

<svg id="map" height="700" width="900" style="background: #fff; margin-top:50px">
  <g id="plot" height="700" width="700"></g>
  <g id="minimap" width="200" height="200" transform="translate(699,1)">
    <rect x="0" y="0" width="200" height="200" stroke="black" stroke-width="1" fill="white" opacity="1" />
  </g>
</svg>

<script>

  const plot = d3.select("svg g#plot");
  const width = plot.attr("width");
  const height = plot.attr("height");
  const margin = { top: 5, right: 5, bottom: 35, left: 35 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;
  const chartArea = plot.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  plot.append("defs").append("clipPath")
    .attr("id", "chartClip")
    .append("rect").attr("x", 0)
    .attr("y", 0)
    .attr("width", chartWidth)
    .attr("height", chartHeight);

  chartArea.attr("clip-path", "url(#chartClip)");

  function plotRestaurants(data, projection, nhoods) {
    const jitterSize = 2;

    data.forEach(d => {
      d.isInside = nhoods.features.some(nhood => d3.geoContains(nhood, [+d.longitude, +d.latitude]));
    });

    let viewport = chartArea.append("g");
    let circles = viewport.selectAll("circle")
      .data(data)
      .enter()
      .append("circle")
      .attr("cx", d => {
        const [x,] = projection([+d.longitude, +d.latitude]);
        return x + (Math.random() - 0.5) * jitterSize;
      })
      .attr("cy", d => {
        const [, y] = projection([+d.longitude, +d.latitude]);
        return y + (Math.random() - 0.5) * jitterSize;
      })
      .attr("r", "3")
      .attr("opacity", 0.8)
      .attr("fill", d => d.isInside ? "steelblue" : "none")
      .on('mouseover', function (event, d) {
        if (d.isInside) {
          d3.select(this)
            .transition()
            .duration(150)
            .style('fill', 'deepskyblue')
            .style('opacity', 1);

          circles.filter((_, i, nodes) => this !== nodes[i] && d3.select(nodes[i]).datum().isInside)
            .transition()
            .duration(150)
            .style('opacity', 0.2);
        }
      })
      .on('mouseout', function () {
        circles.filter(d => d.isInside)
          .transition()
          .duration(150)
          .style('fill', d => d.isInside ? 'steelblue' : 'none')
          .style('opacity', 0.8);
      });
  }

  const requestData = async () => {
    const boston = await d3.json("boston.topo.json");
    const restaurants = await d3.csv("yelp_boston.csv");

    console.log(boston);
    console.log(restaurants);

    var nhoods = topojson.feature(boston, boston.objects.boston)
    var nhoodsMesh = topojson.mesh(boston, boston.objects.boston);

    var mainProjection = d3.geoMercator().fitSize([chartWidth, chartHeight], nhoods);
    var path = d3.geoPath().projection(mainProjection);

    let nhoodsPaths = chartArea.selectAll("path.nhood")
      .data(nhoods.features)
      .join("path")
      .attr("class", "nhood")
      .attr("d", path);

    chartArea.append("path").datum(nhoodsMesh)
      .attr("class", "nhood-outline")
      .attr("d", path);

    let zoomExtent = [[0, 0], [chartWidth, chartHeight]];
    let translateExtent = [[-100, -100], [chartWidth + 100, chartHeight + 100]];
    var plotZoom = d3.zoom()
      .extent(zoomExtent)
      .translateExtent(translateExtent)
      .scaleExtent([1, 10])
      .on('zoom', plotZoomed);

    chartArea.call(plotZoom);

    plotRestaurants(restaurants, mainProjection, nhoods);

    const minimap = d3.select("svg g#minimap");
    const minimapMargin = { top: 4, right: 4, bottom: 4, left: 4 };
    const minimapWidth = minimap.attr("width") - minimapMargin.left - minimapMargin.right;
    const minimapHeight = minimap.attr("height") - minimapMargin.top - minimapMargin.bottom;
    const minimapArea = minimap.append("g")
      .attr("transform", "translate(" + minimapMargin.left + "," + minimapMargin.top + ")")
      .attr("opacity", 0.5);

    var minimapProjection = d3.geoMercator()
      .fitSize([minimapWidth, minimapHeight], nhoods);
    var minimapPath = d3.geoPath().projection(minimapProjection);

    minimapArea.selectAll("path")
      .data(nhoods.features)
      .enter().append("path")
      .attr("d", minimapPath)
      .attr("class", "nhood")
      .style("fill", "#CCC")
      .style("stroke", "#333");

    let brushGroup = minimapArea.append("g").attr("class", "brush");
    let brush = d3.brush()
      .extent([[0, 0], [minimapWidth, minimapHeight]])
      .on("brush", brushed)
    brushGroup.call(brush)

    function plotZoomed({ transform }) {
      chartArea.attr('transform', transform);
      plot.selectAll("circle")
        .attr("r", 3 / transform.k + "px");

      chartArea.selectAll(".nhood-outline, .nhood")
        .style("stroke-width", 1 / transform.k + "px");

      const topLeft = [transform.invertX(0), transform.invertY(0)];
      const bottomRight = [transform.invertX(width), transform.invertY(height)];

      const topLeftGeo = mainProjection.invert(topLeft);
      const bottomRightGeo = mainProjection.invert(bottomRight);

      const minimapTopLeft = minimapProjection(topLeftGeo);
      const minimapBottomRight = minimapProjection(bottomRightGeo);

      brushGroup.call(brush.move, [minimapTopLeft, minimapBottomRight]);
    }

    function brushed(event) {
      let selection = event.selection;
      if (selection) {
        // Constrain the brush to the minimap dimensions
        selection = selection.map(d => {
          return [
            Math.max(0, Math.min(d[0], minimapWidth)),
            Math.max(0, Math.min(d[1], minimapHeight))
          ];
        });

        // If the selection is outside the minimap bounds, reset it to the bounds
        if (selection[0][0] === minimapWidth) {
          selection[0][0] = minimapWidth - 1;
        }
        if (selection[1][0] === 0) {
          selection[1][0] = 1;
        }
        if (selection[0][1] === minimapHeight) {
          selection[0][1] = minimapHeight - 1;
        }
        if (selection[1][1] === 0) {
          selection[1][1] = 1;
        }

        // Now set the brush selection to the constrained selection
        d3.select(this).call(brush.move, selection);
      }
    }


    chartArea.call(plotZoom.transform, d3.zoomIdentity);

  }

  requestData();
</script>

</body>

</html>